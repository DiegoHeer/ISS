import xlwings as xw
import pymsgbox
import json
import os
from os.path import dirname, join
import requests
from bs4 import BeautifulSoup

import quickfs_scraping.process
import quickfs_scraping.api_scraping
from quickfs_scraping.excel_handler import excel_to_dataframe, check_validity_output_file, excel_sheet_exists
from technical_analysis.ta import TA


def ask_ticker_to_user():
    # Aak ticker to user
    ticker = pymsgbox.prompt('Please enter a valid ticker: ')
    assert isinstance(ticker, str)

    return ticker.upper()


def get_fs_dir_path():
    # This function gets the directory where the financial statements generated by
    # quickfs_scraping module are
    module_path = dirname(dirname(quickfs_scraping.__file__))

    return join(module_path, 'financial_files', 'excel')


def load_json_file(json_path):
    with open(json_path, 'r') as file:
        json_file = json.load(file)

    return json_file


def save_json_file(json_file, json_file_path):
    with open(json_file_path, 'w') as file:
        json.dump(json_file, file, indent=4, sort_keys=True)


def gen_technical_analysis_chart(ticker, show_fig=True):
    months_observations = 3
    chart_storage_path = r"D:\PythonProjects\iss\iss\data\ta_charts"

    chart = TA(ticker)
    chart.get_price_history()
    chart.get_indicators()
    chart.plot_chart(months_observations, fig_dir=chart_storage_path, show_fig=show_fig)


def translate_dict_keys(rule1_dict, sheet_name):
    # Translate dictionary, substituting current keys by table keys
    translation_dict_path = join(dirname(__file__), 'data', 'iss_translation_dict.json')
    translation_dict = load_json_file(translation_dict_path)

    table_header_list = translation_dict[sheet_name]['table_headers']
    rule1_metrics_list = translation_dict[sheet_name]['rule1_metrics']

    result_dict = dict()
    for i, value in enumerate(table_header_list):
        if rule1_metrics_list[i] in rule1_dict:
            result_dict[value] = rule1_dict[rule1_metrics_list[i]]

    return result_dict


def gen_fs_excel_file(ticker):
    quickfs_scraping.process.run(ticker, bool_batch=True)


def get_full_featured_tradingview_chart(base_url):
    req = requests.get(base_url).content
    soup = BeautifulSoup(req, features='lxml')

    start_link = soup.find('a', class_='tv-goto-chart-button tv-goto-chart-button--mobile js-go-to-chart-button-mobile',
                     target="_blank")

    return "https://www.tradingview.com" + str(start_link.get('href'))


class FSHandler:
    def __init__(self, sheet_name):
        self.sheet_name = sheet_name.capitalize()
        self.wb = xw.Book.caller()
        self.wb_path = self.wb.fullname
        self.ws = self.wb.sheets[self.sheet_name].api
        self.fs_dir = get_fs_dir_path()

        if self.sheet_name != "Portfolio":
            self.table = self.ws.ListObjects(self.sheet_name)

        self.ticker_dump_dict_path = join(dirname(__file__), 'data', 'ticker_dump_dict.json')

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        pass

    def table_to_ticker_list(self, only_updated=True):
        ticker_list = list()
        for i in range(1, self.table.ListRows.Count + 1):
            ticker = self.table.ListColumns('Ticker').DataBodyRange(i).Value
            status = self.table.ListColumns('Status').DataBodyRange(i).Value

            if (status != 'Updated' and status != 'Hold') or only_updated is False:
                ticker_list.append(ticker)

        return ticker_list

    def get_fs_excel_path(self, ticker):
        return join(self.fs_dir, ticker.upper() + ".xlsx")

    def open_fs_excel_file(self, ticker):
        excel_file = self.get_fs_excel_path(ticker)

        try:
            os.startfile(excel_file)
        except:
            pymsgbox.alert(f"Excel file for {ticker} doesn't exist or is being used by another process",
                           "Error opening file")
            exit()

    def delete_ticker_from_table(self, ticker):
        # Check first if ticker really is in table
        ticker_list = self.table_to_ticker_list(only_updated=False)
        if ticker not in ticker_list:
            pymsgbox.alert(f"The ticker {ticker} is not present in the {self.sheet_name} table.")
            exit()

        # Remove filter from table if there is
        self.table.ShowAutoFilter = False
        self.table.ShowAutoFilter = True

        # Delete row that has the ticker
        for i in range(1, self.table.ListRows.Count + 1):
            if self.table.ListColumns('Ticker').DataBodyRange(i).Value == ticker:
                self.table.ListRows(i).Delete()

    def add_ticker_to_table(self, ticker, sheet_name):
        # Obtain the correct objects for the specific sheet
        self.ws = self.wb.sheets[sheet_name].api
        self.table = self.ws.ListObjects(sheet_name)

        # Check if ticker already doesn't exists in table
        ticker_list = self.table_to_ticker_list(only_updated=False)
        if ticker in ticker_list:
            pymsgbox.alert(f"The ticker {ticker} is already present in the {self.sheet_name} table.")
            exit()

        # Create new row and add the ticker
        self.table.ListRows.Add(AlwaysInsert=True)
        last_row = self.table.ListRows.Count
        self.table.ListColumns('Ticker').DataBodyRange(last_row).Value = ticker

        # Add suggestions to unfilled qualitative columns
        self.watchlist_status_suggestion(last_row)

        # Change status of ticker in watchlist
        self.table.ListColumns('Status').DataBodyRange(last_row).Value = "New"

    def watchlist_status_suggestion(self, row):
        # Check status suggestion for unfilled cells in user evaluation columns
        columns = ['Personal Approval', 'Meaning Approved', 'Management Approved']
        for header in columns:
            if self.table.ListColumns(header).DataBodyRange(row).Value is None:
                self.table.ListColumns(header).DataBodyRange(row).Value = "CHECK"

    def check_validity_excel_file(self, ticker):
        excel_path = self.get_fs_excel_path(ticker)

        if check_validity_output_file(excel_path):
            if excel_sheet_exists(excel_path, source=self.sheet_name):
                return True
            else:
                return False
        else:
            return False

    def extract_rule1_metrics_data(self, ticker):
        # Check if financial excel file is available and updated.
        # If not, create a new one
        if not self.check_validity_excel_file(ticker):
            gen_fs_excel_file(ticker)

        # Get the data from the fs excel file in a dataframe format
        rule1_df = excel_to_dataframe(self.get_fs_excel_path(ticker), source='rule1_results')

        # Turn first column into index
        rule1_df = rule1_df.set_index('Rule #1 Metric')

        # Transform dataframe into dictionary
        rule1_dict = rule1_df.to_dict()['Value']

        # Translate dictionary, substituting current keys by table keys
        rule1_dict = translate_dict_keys(rule1_dict, self.sheet_name)

        return rule1_dict

    def ta_to_watchlist(self):
        # This function gets the most recent buy-sell signals and puts them in the watchlist
        if self.sheet_name == 'Watchlist':
            for i in range(1, self.table.ListRows.Count + 1):
                ticker = self.table.ListColumns('Ticker').DataBodyRange(i).Value

                ta_data = TA(ticker)
                ta_data.get_price_history()
                ta_data.get_indicators()

                self.table.ListColumns('MACD Status').DataBodyRange(i).Value = ta_data.get_macd_buy_sell().upper()
                self.table.ListColumns('MA Status').DataBodyRange(i).Value = ta_data.get_ma10_buy_sell().upper()
                self.table.ListColumns('Stochastics Status').DataBodyRange(
                    i).Value = ta_data.get_stoch_buy_sell().upper()

        else:
            pass

    def rule1_data_to_table(self):
        ticker_list = self.table_to_ticker_list()

        if len(ticker_list) == 0:
            pymsgbox.alert("All tickers are already updated. Please change status if you want to update again.",
                           "All tickers already updated")
            exit()

        # Get list of tickers that were dumped, for later comparison
        dumped_tickers = self.get_dumped_tickers()

        for i in range(1, self.table.ListRows.Count + 1):
            ticker = self.table.ListColumns('Ticker').DataBodyRange(i).Value

            # Check if ticker already has been deleted previously for not satisfying MOAT requirements
            if ticker in dumped_tickers:
                user_answer = pymsgbox.confirm(
                    f"The ticker {ticker} was previously dumped for failing MOAT requirements. "
                    f"Still want to continue updating for this ticker?",
                    "Ticker previously dumped", buttons=(pymsgbox.YES_TEXT, pymsgbox.NO_TEXT))
                if user_answer == pymsgbox.NO_TEXT:
                    continue

            if ticker in ticker_list:
                rule1_dict = self.extract_rule1_metrics_data(ticker)

                # Put the data in the right location
                for key, value in rule1_dict.items():
                    self.table.ListColumns(key).DataBodyRange(i).Value = value

                # Change status of ticker in table
                self.table.ListColumns('Status').DataBodyRange(i).Value = 'Updated'

                # Add suggestions to unfilled qualitative columns if it is watchlist
                if self.sheet_name == 'Watchlist':
                    self.watchlist_status_suggestion(i)

    def dump_non_approved_tickers(self, bool_check_included=False):
        # Load the json file were the dumped tickers will be hold
        ticker_dump_dict = load_json_file(self.ticker_dump_dict_path)

        # List that will be used later to delete the tickers from the table
        ticker_removal_list = list()

        # Initiate loop to fill in the dump dictionary
        for i in range(1, self.table.ListRows.Count + 1):
            ticker = self.table.ListColumns('Ticker').DataBodyRange(i).Value
            moat_approval = self.table.ListColumns('MOAT Approval').DataBodyRange(i).Value
            status = self.table.ListColumns('Status').DataBodyRange(i).Value

            # Define metrics that will be added to the dictionary
            company_name = self.table.ListColumns('Company Name').DataBodyRange(i).Value
            roic_approval = self.table.ListColumns('ROIC Approval').DataBodyRange(i).Value
            roic_quickfs_approval = self.table.ListColumns('ROIC QuickFS Approval').DataBodyRange(i).Value
            equity_approval = self.table.ListColumns('Equity Approval').DataBodyRange(i).Value
            eps_approval = self.table.ListColumns('EPS Approval').DataBodyRange(i).Value
            sales_approval = self.table.ListColumns('Sales Approval').DataBodyRange(i).Value
            fcf_approval = self.table.ListColumns('FCF Approval').DataBodyRange(i).Value
            ocf_approval = self.table.ListColumns('OCF Approval').DataBodyRange(i).Value
            debt_payoff_approval = self.table.ListColumns('Debt - Payoff Possible').DataBodyRange(i).Value

            if status == "Updated":
                if moat_approval is False or (moat_approval == "CHECK" and bool_check_included is True):
                    # Add parameters to the dictionary
                    ticker_dump_dict[ticker] = dict()
                    ticker_dump_dict[ticker]['moat_approval'] = moat_approval
                    ticker_dump_dict[ticker]['company_name'] = company_name
                    ticker_dump_dict[ticker]['roic_approval'] = roic_approval
                    ticker_dump_dict[ticker]['roic_quickfs_approval'] = roic_quickfs_approval
                    ticker_dump_dict[ticker]['equity_approval'] = equity_approval
                    ticker_dump_dict[ticker]['eps_approval'] = eps_approval
                    ticker_dump_dict[ticker]['sales_approval'] = sales_approval
                    ticker_dump_dict[ticker]['fcf_approval'] = fcf_approval
                    ticker_dump_dict[ticker]['ocf_approval'] = ocf_approval
                    ticker_dump_dict[ticker]['debt_payoff_approval'] = debt_payoff_approval

                    # Add ticker to list
                    ticker_removal_list.append(ticker)

        # Save the dumped tickers to the json file
        save_json_file(ticker_dump_dict, self.ticker_dump_dict_path)

        # Delete the dumped ticker rows from the table
        for dumped_ticker in ticker_removal_list:
            self.delete_ticker_from_table(dumped_ticker)

    def get_dumped_tickers(self):
        # Load the json file were the dumped tickers are hold
        ticker_dump_dict = load_json_file(self.ticker_dump_dict_path)

        # Make list of the dumped tickers
        dumped_ticker_list = list()
        for key, value in ticker_dump_dict.items():
            dumped_ticker_list.append(key)

        return dumped_ticker_list
